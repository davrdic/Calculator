3!; (6/(3!))/(1/6)*30; 3**4; 3*8/(4*2)!+-3*14.3;


/*
Class: Token_stream

Description: This class will be used as a buffer to hold a token.
It comes equipped with two public functions, one to get a token
from user input or the buffer. the other to put a token in the
buffer. two private variables will be needed by for member functions
to carry out their task. One is a Token that is the actual buffer,
the other is a bool that keeps track of whether or not the buffer
is full
*/

class Token_stream {
public:
    Token_stream();
    Token get();
    void putback(Token t);
    void ignore(char c);
private:
    bool full;
    Token buffer;
};

/*
Token_stream constructor: initializes buffer to empty
*/

Token_stream::Token_stream()
    :full(false), buffer(0)
{
}

/*
Token_stream member function get(): gets a token from the buffer or a 
character from the user input stream and assigns it to the appropriate 
token
*/

Token Token_stream::get()
{
    if (full) {
        full = false;
        return buffer;
    }

    char ch;
    cin >> ch;

    switch (ch) {
    case quit:
    case print:
    case '!': 
    case '{': 
    case '}': 
    case '(': 
    case ')': 
    case '+': 
    case '-': 
    case '*': 
    case '/': 
    case '%':
        return Token(ch);
    case '.':
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token(number, val);
    }
    default:
        error("Bad token");
    }
}

/*
Token_stream member function putback(): puts a token in the buffer
*/

void Token_stream::putback(Token t)
{
    if (full) error("putback() into a full buffer");
    buffer = t;
    full = true;
}

/*
Token_stream member function ignore(): clears input stream and buffer.
*/

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;
    char ch = 0;
    while (cin >> ch)
        if (ch == c)return;
}